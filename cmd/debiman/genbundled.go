// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"strings"
	"text/template"
)

var output = flag.String("output", "GENERATED_bundled.go", "Where to put the variable declarations")
var pkgname = flag.String("package", "main", "What package should the output file belong to")

var bundledTmpl = template.Must(template.New("embedded").Parse(`
package {{ .Package }}

// Generated by "go run genbundled.go {{ .Args }}".
// Do not edit manually.

var bundled = map[string][]byte{
{{ range $i, $t := .Templates -}}
  {{ $t.NameLiteral }}: {{ $t.ContentLiteral }},
{{ end -}}
}

`))

func main() {
	flag.Parse()

	if flag.NArg() < 1 {
		log.Fatal("Must provide at least one file to bundle")
	}

	type nameAndContent struct {
		NameLiteral    string
		ContentLiteral string
	}
	tmpls := make([]nameAndContent, flag.NArg())
	for i := 0; i < flag.NArg(); i++ {
		n := flag.Arg(i)
		b, err := ioutil.ReadFile(n)
		if err != nil {
			log.Fatal(err)
		}

		tmpls[i] = nameAndContent{
			NameLiteral:    fmt.Sprintf("%#v", flag.Arg(i)),
			ContentLiteral: fmt.Sprintf("%#v", b),
		}
	}

	var buf bytes.Buffer
	if err := bundledTmpl.Execute(&buf, struct {
		Package   string
		Args      string
		Templates []nameAndContent
	}{
		Package:   *pkgname,
		Args:      strings.Join(flag.Args(), " "),
		Templates: tmpls,
	}); err != nil {
		log.Fatal(err)
	}

	outsrc, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Could not format output: %v\nOutput:\n%s", buf.String(), err)
	}

	if err := ioutil.WriteFile(*output, outsrc, 0644); err != nil {
		log.Fatalf("Could not write output: %v", err)
	}
}
